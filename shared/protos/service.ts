/* eslint-disable */
// @generated by protobuf-ts 2.9.0 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "service.proto" (package "elephant.repository", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message elephant.repository.GetStatusHistoryRequest
 */
export interface GetStatusHistoryRequest {
    /**
     * UUID of the document to get the status history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Name of the status to get.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Before is a status ID used to page backwards through the status history. If
     * no ID or a zero ID is provided the list will start with the lastest status.
     *
     * @generated from protobuf field: int64 before = 3;
     */
    before: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusHistoryReponse
 */
export interface GetStatusHistoryReponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Status statuses = 1;
     */
    statuses: Status[];
}
/**
 * @generated from protobuf message elephant.repository.GetEventlogRequest
 */
export interface GetEventlogRequest {
    /**
     * After specifies the event ID after which to start returning events.
     *
     * @generated from protobuf field: int64 after = 1;
     */
    after: bigint;
    /**
     * Wait is the maximum time to wait for new events. Defaults to 2000.
     *
     * @generated from protobuf field: int32 waitMs = 2;
     */
    waitMs: number;
    /**
     * BatchSize is the number of events we want in the response. Defaults to 10.
     *
     * @generated from protobuf field: int32 batchSize = 3;
     */
    batchSize: number;
    /**
     * BatchWaitMs is the maximum time we wait for a batch to be filled. Defaults to 200.
     *
     * @generated from protobuf field: int32 batchWaitMs = 4;
     */
    batchWaitMs: number;
}
/**
 * @generated from protobuf message elephant.repository.GetEventlogResponse
 */
export interface GetEventlogResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.EventlogItem items = 1;
     */
    items: EventlogItem[];
}
/**
 * @generated from protobuf message elephant.repository.EventlogItem
 */
export interface EventlogItem {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: string event = 2;
     */
    event: string;
    /**
     * @generated from protobuf field: string uuid = 3;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string timestamp = 4;
     */
    timestamp: string;
    /**
     * @generated from protobuf field: int64 version = 5;
     */
    version: bigint;
    /**
     * @generated from protobuf field: string status = 6;
     */
    status: string;
    /**
     * @generated from protobuf field: int64 status_id = 7;
     */
    statusId: bigint;
    /**
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 8;
     */
    acl: ACLEntry[];
    /**
     * @generated from protobuf field: string updater_uri = 9;
     */
    updaterUri: string;
    /**
     * @generated from protobuf field: string type = 10;
     */
    type: string;
}
/**
 * @generated from protobuf message elephant.repository.RunReportRequest
 */
export interface RunReportRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.RunReportResponse
 */
export interface RunReportResponse {
    /**
     * @generated from protobuf field: repeated string tables = 1;
     */
    tables: string[];
    /**
     * @generated from protobuf field: bytes spreadsheet = 2;
     */
    spreadsheet: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.TestReportRequest
 */
export interface TestReportRequest {
    /**
     * @generated from protobuf field: elephant.repository.Report report = 1;
     */
    report?: Report;
}
/**
 * @generated from protobuf message elephant.repository.TestReportResponse
 */
export interface TestReportResponse {
    /**
     * @generated from protobuf field: repeated string tables = 1;
     */
    tables: string[];
    /**
     * @generated from protobuf field: bytes spreadsheet = 2;
     */
    spreadsheet: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.GetReportRequest
 */
export interface GetReportRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.GetReportResponse
 */
export interface GetReportResponse {
    /**
     * @generated from protobuf field: elephant.repository.Report report = 1;
     */
    report?: Report;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: string next_execution = 3;
     */
    nextExecution: string;
}
/**
 * @generated from protobuf message elephant.repository.UpdateReportRequest
 */
export interface UpdateReportRequest {
    /**
     * @generated from protobuf field: elephant.repository.Report report = 1;
     */
    report?: Report;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
}
/**
 * @generated from protobuf message elephant.repository.Report
 */
export interface Report {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: bool generate_sheet = 3;
     */
    generateSheet: boolean;
    /**
     * @generated from protobuf field: string cron_expression = 4;
     */
    cronExpression: string;
    /**
     * @generated from protobuf field: string cron_timezone = 7;
     */
    cronTimezone: string; // (default UTC)
    /**
     * @generated from protobuf field: repeated string slack_channels = 5;
     */
    slackChannels: string[];
    /**
     * @generated from protobuf field: repeated elephant.repository.ReportQuery queries = 6;
     */
    queries: ReportQuery[];
}
/**
 * @generated from protobuf message elephant.repository.ReportQuery
 */
export interface ReportQuery {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated int32 summarise = 2;
     */
    summarise: number[];
    /**
     * @generated from protobuf field: string sql = 3;
     */
    sql: string;
    /**
     * @generated from protobuf field: repeated elephant.repository.ReportValue value_processing = 4;
     */
    valueProcessing: ReportValue[];
}
/**
 * @generated from protobuf message elephant.repository.ReportValue
 */
export interface ReportValue {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * @generated from protobuf field: repeated string processors = 2;
     */
    processors: string[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateReportResponse
 */
export interface UpdateReportResponse {
    /**
     * @generated from protobuf field: string next_execution = 1;
     */
    nextExecution: string;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusRulesRequest
 */
export interface GetStatusRulesRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetStatusRulesResponse
 */
export interface GetStatusRulesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.StatusRule rules = 1;
     */
    rules: StatusRule[];
}
/**
 * @generated from protobuf message elephant.repository.GetStatusesRequest
 */
export interface GetStatusesRequest {
}
/**
 * @generated from protobuf message elephant.repository.WorkflowStatus
 */
export interface WorkflowStatus {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.GetStatusesResponse
 */
export interface GetStatusesResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.WorkflowStatus statuses = 1;
     */
    statuses: WorkflowStatus[];
}
/**
 * @generated from protobuf message elephant.repository.UpdateStatusRequest
 */
export interface UpdateStatusRequest {
    /**
     * Name of the status.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Disabled disables the status so that it cannot be used when setting new
     * statuses.
     *
     * @generated from protobuf field: bool disabled = 2;
     */
    disabled: boolean;
}
/**
 * @generated from protobuf message elephant.repository.UpdateStatusResponse
 */
export interface UpdateStatusResponse {
}
/**
 * @generated from protobuf message elephant.repository.CreateStatusRuleRequest
 */
export interface CreateStatusRuleRequest {
    /**
     * @generated from protobuf field: elephant.repository.StatusRule rule = 1;
     */
    rule?: StatusRule;
}
/**
 * @generated from protobuf message elephant.repository.StatusRule
 */
export interface StatusRule {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: bool access_rule = 3;
     */
    accessRule: boolean;
    /**
     * @generated from protobuf field: repeated string applies_to = 4;
     */
    appliesTo: string[];
    /**
     * @generated from protobuf field: repeated string for_types = 5;
     */
    forTypes: string[];
    /**
     * @generated from protobuf field: string expression = 6;
     */
    expression: string;
}
/**
 * @generated from protobuf message elephant.repository.CreateStatusRuleResponse
 */
export interface CreateStatusRuleResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteStatusRuleRequest
 */
export interface DeleteStatusRuleRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteStatusRuleResponse
 */
export interface DeleteStatusRuleResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentRequest
 */
export interface GetDocumentRequest {
    /**
     * UUID of the document to get.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Version to get, omit to get latest (or use status).
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Status is used to fetch the version of the document references by the last
     * status update. Can be used instead of specifying a version.
     *
     * @generated from protobuf field: string status = 3;
     */
    status: string;
    /**
     * Lock will lock the document for updates. This only affects the creation of
     * new versions of the document, statuses can still be updated.
     *
     * @generated from protobuf field: bool lock = 4;
     */
    lock: boolean;
}
/**
 * @generated from protobuf message elephant.repository.GetDocumentResponse
 */
export interface GetDocumentResponse {
    /**
     * @generated from protobuf field: elephant.repository.Document document = 1;
     */
    document?: Document;
    /**
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetHistoryRequest
 */
export interface GetHistoryRequest {
    /**
     * UUID of the document to get the history for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Before is which version number we should start fetching history from, omit
     * to start with the latest version.
     *
     * @generated from protobuf field: int64 before = 2;
     */
    before: bigint;
}
/**
 * @generated from protobuf message elephant.repository.GetHistoryResponse
 */
export interface GetHistoryResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.DocumentVersion versions = 1;
     */
    versions: DocumentVersion[];
}
/**
 * @generated from protobuf message elephant.repository.DocumentVersion
 */
export interface DocumentVersion {
    /**
     * Version of the document.
     *
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
    /**
     * Created timestamp is the RFC3339 timestamp for when the version was
     * created.
     *
     * @generated from protobuf field: string created = 2;
     */
    created: string;
    /**
     * Creator of the version.
     *
     * @generated from protobuf field: string creator = 3;
     */
    creator: string;
    /**
     * Meta data to for the document version.
     *
     * @generated from protobuf field: map<string, string> meta = 4;
     */
    meta: {
        [key: string]: string;
    };
}
/**
 * UpdateRequest creates a new document version and/or sets statuses and ACLs
 * for a document. The update is transactional will fail or succed as a whole.
 *
 * If the document fails validation an "invalid_argument" error will be returned
 * with the number of errors as meta "err_count" and the individual errors as
 * "0", "1", "2"... Use the Validate method to get th errors as structured data.
 *
 * @generated from protobuf message elephant.repository.UpdateRequest
 */
export interface UpdateRequest {
    /**
     * UUID of the document to update.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Document version to create.
     *
     * @generated from protobuf field: elephant.repository.Document document = 2;
     */
    document?: Document;
    /**
     * Meta data to associate with the document version.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the version that you require
     * to be the current one for the update to be performed, or -1 to only perform
     * the update if the document doesn't already exist.
     *
     * @generated from protobuf field: int64 if_match = 4;
     */
    ifMatch: bigint;
    /**
     * Status updates to perform.
     *
     * @generated from protobuf field: repeated elephant.repository.StatusUpdate status = 5;
     */
    status: StatusUpdate[];
    /**
     * ACL is an ACL list controlling access to the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 6;
     */
    acl: ACLEntry[];
    /**
     * ImportDirective can be used to preserve timestamps and authorship
     * information from originating systems, but requires the "import_directive"
     * scope for use.
     *
     * @generated from protobuf field: elephant.repository.ImportDirective import_directive = 7;
     */
    importDirective?: ImportDirective;
}
/**
 * ImportDirective can be used to preserve timestamps and authorship information
 * from originating systems.
 *
 * @generated from protobuf message elephant.repository.ImportDirective
 */
export interface ImportDirective {
    /**
     * @generated from protobuf field: string originallyCreated = 1;
     */
    originallyCreated: string;
    /**
     * @generated from protobuf field: string originalCreator = 2;
     */
    originalCreator: string;
}
/**
 * UpdateResponse describes the result of an update request.
 *
 * @generated from protobuf message elephant.repository.UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: int64 version = 1;
     */
    version: bigint;
}
/**
 * @generated from protobuf message elephant.repository.ValidateRequest
 */
export interface ValidateRequest {
    /**
     * @generated from protobuf field: elephant.repository.Document document = 1;
     */
    document?: Document;
}
/**
 * @generated from protobuf message elephant.repository.ValidateResponse
 */
export interface ValidateResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.ValidationResult errors = 1;
     */
    errors: ValidationResult[];
}
/**
 * @generated from protobuf message elephant.repository.ValidationResult
 */
export interface ValidationResult {
    /**
     * @generated from protobuf field: repeated elephant.repository.EntityRef entity = 1;
     */
    entity: EntityRef[];
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message elephant.repository.EntityRef
 */
export interface EntityRef {
    /**
     * RefType is type of entity that's referenced, one of "block", "property",
     * "attribute", "data attribute", or "parameter."
     *
     * @generated from protobuf field: string ref_type = 1;
     */
    refType: string;
    /**
     * Kind is the block type, one of "link", "meta", or "content".
     *
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * Index is the position of the entity in an array, where applicable.
     *
     * @generated from protobuf field: int64 index = 3;
     */
    index: bigint;
    /**
     * Name is the name of the entity, where applicable.
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * Type is the type of the entity, where applicable.
     *
     * @generated from protobuf field: string type = 5;
     */
    type: string;
    /**
     * Rel is the relationship for the entity, where applicable.
     *
     * @generated from protobuf field: string rel = 6;
     */
    rel: string;
}
/**
 * @generated from protobuf message elephant.repository.StatusUpdate
 */
export interface StatusUpdate {
    /**
     * Name of the status to set.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version to set the status for. Set to -1 to signal that the status no
     * longer is valid for the document. Optional if part of a document update
     * request as it then will default to the version being written.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Meta data to include with the status update.
     *
     * @generated from protobuf field: map<string, string> meta = 3;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the status id that you require
     * to be the current one for the status to be set, or -1 to only perform the
     * update if the status hasn't previously been set.
     *
     * @generated from protobuf field: int64 if_match = 4;
     */
    ifMatch: bigint;
}
/**
 * @generated from protobuf message elephant.repository.UpdatePermissionsRequest
 */
export interface UpdatePermissionsRequest {
    /**
     * UUID of the document to update permissions for.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Set (upsert based on URI) this list of ACL entries.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry list = 2;
     */
    list: ACLEntry[];
}
/**
 * @generated from protobuf message elephant.repository.UpdatePermissionsResponse
 */
export interface UpdatePermissionsResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteDocumentRequest
 */
export interface DeleteDocumentRequest {
    /**
     * UUID of the document to delete.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Meta data to include with the delete record.
     *
     * @generated from protobuf field: map<string, string> meta = 2;
     */
    meta: {
        [key: string]: string;
    };
    /**
     * IfMatch is used for optimistic locks. Set to the version that you require
     * to be the current one for the delete to be performed.
     *
     * @generated from protobuf field: int64 if_match = 3;
     */
    ifMatch: bigint;
}
/**
 * @generated from protobuf message elephant.repository.DeleteDocumentResponse
 */
export interface DeleteDocumentResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetaRequest
 */
export interface GetMetaRequest {
    /**
     * UUID of the document to get metadata for
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message elephant.repository.GetMetaResponse
 */
export interface GetMetaResponse {
    /**
     * @generated from protobuf field: elephant.repository.DocumentMeta meta = 1;
     */
    meta?: DocumentMeta;
}
/**
 * @generated from protobuf message elephant.repository.DocumentMeta
 */
export interface DocumentMeta {
    /**
     * Created timestamp is the RFC3339 timestamp for when the document was
     * created.
     *
     * @generated from protobuf field: string created = 1;
     */
    created: string;
    /**
     * Modified timestamp is the RFC3339 timestamp for the last change that
     * affected the document.
     *
     * @generated from protobuf field: string modified = 2;
     */
    modified: string;
    /**
     * CurrentVersion is the last written vrsion of the document.
     *
     * @generated from protobuf field: int64 currentVersion = 3;
     */
    current_version: bigint;
    /**
     * Heads are the last statuses.
     *
     * @generated from protobuf field: map<string, elephant.repository.Status> heads = 4;
     */
    heads: {
        [key: string]: Status;
    };
    /**
     * ACL is an ACL list controlling access to the document.
     *
     * @generated from protobuf field: repeated elephant.repository.ACLEntry acl = 5;
     */
    acl: ACLEntry[];
}
/**
 * @generated from protobuf message elephant.repository.Status
 */
export interface Status {
    /**
     * ID of the status.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * Version of the document that the status refers to.
     *
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * Creator of the status.
     *
     * @generated from protobuf field: string creator = 3;
     */
    creator: string;
    /**
     * Created timestamp is the RFC3339 timestamp for when the statue was created.
     *
     * @generated from protobuf field: string created = 4;
     */
    created: string;
    /**
     * Meta data for the status.
     *
     * @generated from protobuf field: map<string, string> meta = 5;
     */
    meta: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repository.ACLEntry
 */
export interface ACLEntry {
    /**
     * URI that identifies the party that's granted access.
     *
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
    /**
     * Permissions given to the grantee.
     *
     * @generated from protobuf field: repeated string permissions = 2;
     */
    permissions: string[];
}
/**
 * Document is the content
 *
 * @generated from protobuf message elephant.repository.Document
 */
export interface Document {
    /**
     * UUID is a unique ID for the document, this can be a random v4
     * UUID, or a URI-derived v5 UUID.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * Type is the content type of the document.
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * URI identifies the document (in a more human-readable way than
     * the UUID)
     *
     * @generated from protobuf field: string uri = 3;
     */
    uri: string;
    /**
     * URL is the browseable location of the document (if any)
     *
     * @generated from protobuf field: string url = 4;
     */
    url: string;
    /**
     * Title is the title of the document, often used as the headline
     * when the document is displayed.
     *
     * @generated from protobuf field: string title = 5;
     */
    title: string;
    /**
     * Content is the content of the documen, this is essentially what
     * gets rendered on the page when you view a document.
     *
     * @generated from protobuf field: repeated elephant.repository.Block content = 6;
     */
    content: Block[];
    /**
     * Meta is the metadata for a document, this could be stuff like
     * open graph tags and content profile information.
     *
     * @generated from protobuf field: repeated elephant.repository.Block meta = 7;
     */
    meta: Block[];
    /**
     * Links are links to other resources and entities. This could be
     * links to categories and subject for the document, or authors.
     *
     * @generated from protobuf field: repeated elephant.repository.Block links = 8;
     */
    links: Block[];
    /**
     * Language is the language used in the document as an IETF language
     * tag. F.ex. "en", "en-UK", "es", or "sv-SE".
     *
     * @generated from protobuf field: string language = 9;
     */
    language: string;
}
/**
 * Block is the building block for data embedded in documents. It is
 * used for both content, links and metadata. Blocks have can be
 * nested, but that's nothing to strive for, keep it simple.
 *
 * @generated from protobuf message elephant.repository.Block
 */
export interface Block {
    /**
     * ID is the block ID
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * UUID is used to reference another Document in a block.
     *
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
    /**
     * URI is used to reference another entity in a document.
     *
     * @generated from protobuf field: string uri = 3;
     */
    uri: string;
    /**
     * URL is a browseable URL for the the block.
     *
     * @generated from protobuf field: string url = 4;
     */
    url: string;
    /**
     * Type is the type of the block
     *
     * @generated from protobuf field: string type = 5;
     */
    type: string;
    /**
     * Title is the title/headline of the block, typically used in the
     * presentation of the block.
     *
     * @generated from protobuf field: string title = 6;
     */
    title: string;
    /**
     * Data contains block data
     *
     * @generated from protobuf field: map<string, string> data = 7;
     */
    data: {
        [key: string]: string;
    };
    /**
     * Relationship describes the relationship to the document/parent
     * entity
     *
     * @generated from protobuf field: string rel = 8;
     */
    rel: string;
    /**
     * Role is used for nuancing and qualifying relationships.
     *
     * @generated from protobuf field: string role = 9;
     */
    role: string;
    /**
     * Name is a name for the block. An alternative to "rel" when
     * relationship is a term that doesn't fit.
     *
     * @generated from protobuf field: string name = 10;
     */
    name: string;
    /**
     * Value is a value for the block. Useful when we want to store a
     * primitive value.
     *
     * @generated from protobuf field: string value = 11;
     */
    value: string;
    /**
     * ContentType is used to describe the content type of the
     * block/linked entity if it differs from the type of the block.
     *
     * @generated from protobuf field: string contentType = 12;
     */
    contentType: string;
    /**
     * Links are used to link to other resources and documents.
     *
     * @generated from protobuf field: repeated elephant.repository.Block links = 13;
     */
    links: Block[];
    /**
     * Content is used to embed content blocks.
     *
     * @generated from protobuf field: repeated elephant.repository.Block content = 14;
     */
    content: Block[];
    /**
     * Meta is used to embed metadata
     *
     * @generated from protobuf field: repeated elephant.repository.Block meta = 15;
     */
    meta: Block[];
}
/**
 * @generated from protobuf message elephant.repository.RegisterSchemaRequest
 */
export interface RegisterSchemaRequest {
    /**
     * @generated from protobuf field: elephant.repository.Schema schema = 1;
     */
    schema?: Schema;
    /**
     * Activate the registered schema immediately.
     *
     * @generated from protobuf field: bool activate = 2;
     */
    activate: boolean;
}
/**
 * @generated from protobuf message elephant.repository.RegisterSchemaResponse
 */
export interface RegisterSchemaResponse {
}
/**
 * @generated from protobuf message elephant.repository.SetActiveSchemaRequest
 */
export interface SetActiveSchemaRequest {
    /**
     * Name is the name of the schema to activate or deactivate, required.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version of the schema to activate, required when activating a new version.
     *
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * Deactivate is used to disable a schema, activate new schema versions
     * instead if you want to start using a new version.
     *
     * @generated from protobuf field: bool deactivate = 3;
     */
    deactivate: boolean;
}
/**
 * @generated from protobuf message elephant.repository.SetActiveSchemaResponse
 */
export interface SetActiveSchemaResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * Name of the schema to get.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Version of the schema to get, optional. The currently active version of the
     * schema will be returned if no version is specified.
     *
     * @generated from protobuf field: string version = 2;
     */
    version: string;
}
/**
 * @generated from protobuf message elephant.repository.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: bytes spec = 2;
     */
    spec: Uint8Array;
}
/**
 * @generated from protobuf message elephant.repository.GetAllActiveSchemasRequest
 */
export interface GetAllActiveSchemasRequest {
    /**
     * @generated from protobuf field: int64 wait_seconds = 1;
     */
    waitSeconds: bigint;
    /**
     * @generated from protobuf field: map<string, string> known = 2;
     */
    known: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message elephant.repository.GetAllActiveSchemasResponse
 */
export interface GetAllActiveSchemasResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.Schema schemas = 1;
     */
    schemas: Schema[];
}
/**
 * @generated from protobuf message elephant.repository.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * @generated from protobuf field: string spec = 3;
     */
    spec: string;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricKindRequest
 */
export interface RegisterMetricKindRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: elephant.repository.MetricAggregation aggregation = 2;
     */
    aggregation: MetricAggregation;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricKindResponse
 */
export interface RegisterMetricKindResponse {
}
/**
 * @generated from protobuf message elephant.repository.DeleteMetricKindRequest
 */
export interface DeleteMetricKindRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message elephant.repository.DeleteMetricKindResponse
 */
export interface DeleteMetricKindResponse {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricKindsRequest
 */
export interface GetMetricKindsRequest {
}
/**
 * @generated from protobuf message elephant.repository.GetMetricKindsResponse
 */
export interface GetMetricKindsResponse {
    /**
     * @generated from protobuf field: repeated elephant.repository.MetricKind kinds = 1;
     */
    kinds: MetricKind[];
}
/**
 * @generated from protobuf message elephant.repository.MetricKind
 */
export interface MetricKind {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: elephant.repository.MetricAggregation aggregation = 2;
     */
    aggregation: MetricAggregation;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricRequest
 */
export interface RegisterMetricRequest {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: string label = 3;
     */
    label: string;
    /**
     * @generated from protobuf field: int64 value = 5;
     */
    value: bigint;
}
/**
 * @generated from protobuf message elephant.repository.RegisterMetricResponse
 */
export interface RegisterMetricResponse {
}
/**
 * @generated from protobuf enum elephant.repository.MetricAggregation
 */
export enum MetricAggregation {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: REPLACE = 1;
     */
    REPLACE = 1,
    /**
     * @generated from protobuf enum value: INCREMENT = 2;
     */
    INCREMENT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusHistoryRequest$Type extends MessageType<GetStatusHistoryRequest> {
    constructor() {
        super("elephant.repository.GetStatusHistoryRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "before", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetStatusHistoryRequest>): GetStatusHistoryRequest {
        const message = { uuid: "", name: "", before: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStatusHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusHistoryRequest): GetStatusHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int64 before */ 3:
                    message.before = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int64 before = 3; */
        if (message.before !== 0n)
            writer.tag(3, WireType.Varint).int64(message.before);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusHistoryRequest
 */
export const GetStatusHistoryRequest = new GetStatusHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusHistoryReponse$Type extends MessageType<GetStatusHistoryReponse> {
    constructor() {
        super("elephant.repository.GetStatusHistoryReponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusHistoryReponse>): GetStatusHistoryReponse {
        const message = { statuses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStatusHistoryReponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusHistoryReponse): GetStatusHistoryReponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Status statuses */ 1:
                    message.statuses.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusHistoryReponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Status statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            Status.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusHistoryReponse
 */
export const GetStatusHistoryReponse = new GetStatusHistoryReponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlogRequest$Type extends MessageType<GetEventlogRequest> {
    constructor() {
        super("elephant.repository.GetEventlogRequest", [
            { no: 1, name: "after", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "waitMs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "batchSize", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "batchWaitMs", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEventlogRequest>): GetEventlogRequest {
        const message = { after: 0n, waitMs: 0, batchSize: 0, batchWaitMs: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEventlogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlogRequest): GetEventlogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 after */ 1:
                    message.after = reader.int64().toBigInt();
                    break;
                case /* int32 waitMs */ 2:
                    message.waitMs = reader.int32();
                    break;
                case /* int32 batchSize */ 3:
                    message.batchSize = reader.int32();
                    break;
                case /* int32 batchWaitMs */ 4:
                    message.batchWaitMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventlogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 after = 1; */
        if (message.after !== 0n)
            writer.tag(1, WireType.Varint).int64(message.after);
        /* int32 waitMs = 2; */
        if (message.waitMs !== 0)
            writer.tag(2, WireType.Varint).int32(message.waitMs);
        /* int32 batchSize = 3; */
        if (message.batchSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.batchSize);
        /* int32 batchWaitMs = 4; */
        if (message.batchWaitMs !== 0)
            writer.tag(4, WireType.Varint).int32(message.batchWaitMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetEventlogRequest
 */
export const GetEventlogRequest = new GetEventlogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventlogResponse$Type extends MessageType<GetEventlogResponse> {
    constructor() {
        super("elephant.repository.GetEventlogResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventlogItem }
        ]);
    }
    create(value?: PartialMessage<GetEventlogResponse>): GetEventlogResponse {
        const message = { items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEventlogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventlogResponse): GetEventlogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EventlogItem items */ 1:
                    message.items.push(EventlogItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventlogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EventlogItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            EventlogItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetEventlogResponse
 */
export const GetEventlogResponse = new GetEventlogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventlogItem$Type extends MessageType<EventlogItem> {
    constructor() {
        super("elephant.repository.EventlogItem", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "status_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 9, name: "updater_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventlogItem>): EventlogItem {
        const message = { id: 0n, event: "", uuid: "", timestamp: "", version: 0n, status: "", statusId: 0n, acl: [], updaterUri: "", type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EventlogItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventlogItem): EventlogItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string event */ 2:
                    message.event = reader.string();
                    break;
                case /* string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* string timestamp */ 4:
                    message.timestamp = reader.string();
                    break;
                case /* int64 version */ 5:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string status */ 6:
                    message.status = reader.string();
                    break;
                case /* int64 status_id */ 7:
                    message.statusId = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 8:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string updater_uri */ 9:
                    message.updaterUri = reader.string();
                    break;
                case /* string type */ 10:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventlogItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string event = 2; */
        if (message.event !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.event);
        /* string uuid = 3; */
        if (message.uuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uuid);
        /* string timestamp = 4; */
        if (message.timestamp !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.timestamp);
        /* int64 version = 5; */
        if (message.version !== 0n)
            writer.tag(5, WireType.Varint).int64(message.version);
        /* string status = 6; */
        if (message.status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.status);
        /* int64 status_id = 7; */
        if (message.statusId !== 0n)
            writer.tag(7, WireType.Varint).int64(message.statusId);
        /* repeated elephant.repository.ACLEntry acl = 8; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string updater_uri = 9; */
        if (message.updaterUri !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.updaterUri);
        /* string type = 10; */
        if (message.type !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.EventlogItem
 */
export const EventlogItem = new EventlogItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunReportRequest$Type extends MessageType<RunReportRequest> {
    constructor() {
        super("elephant.repository.RunReportRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunReportRequest>): RunReportRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RunReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunReportRequest): RunReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RunReportRequest
 */
export const RunReportRequest = new RunReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunReportResponse$Type extends MessageType<RunReportResponse> {
    constructor() {
        super("elephant.repository.RunReportResponse", [
            { no: 1, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spreadsheet", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RunReportResponse>): RunReportResponse {
        const message = { tables: [], spreadsheet: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RunReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunReportResponse): RunReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tables */ 1:
                    message.tables.push(reader.string());
                    break;
                case /* bytes spreadsheet */ 2:
                    message.spreadsheet = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tables = 1; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tables[i]);
        /* bytes spreadsheet = 2; */
        if (message.spreadsheet.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spreadsheet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RunReportResponse
 */
export const RunReportResponse = new RunReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestReportRequest$Type extends MessageType<TestReportRequest> {
    constructor() {
        super("elephant.repository.TestReportRequest", [
            { no: 1, name: "report", kind: "message", T: () => Report }
        ]);
    }
    create(value?: PartialMessage<TestReportRequest>): TestReportRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestReportRequest): TestReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.TestReportRequest
 */
export const TestReportRequest = new TestReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestReportResponse$Type extends MessageType<TestReportResponse> {
    constructor() {
        super("elephant.repository.TestReportResponse", [
            { no: 1, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spreadsheet", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TestReportResponse>): TestReportResponse {
        const message = { tables: [], spreadsheet: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestReportResponse): TestReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string tables */ 1:
                    message.tables.push(reader.string());
                    break;
                case /* bytes spreadsheet */ 2:
                    message.spreadsheet = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string tables = 1; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tables[i]);
        /* bytes spreadsheet = 2; */
        if (message.spreadsheet.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spreadsheet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.TestReportResponse
 */
export const TestReportResponse = new TestReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReportRequest$Type extends MessageType<GetReportRequest> {
    constructor() {
        super("elephant.repository.GetReportRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetReportRequest>): GetReportRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReportRequest): GetReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetReportRequest
 */
export const GetReportRequest = new GetReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReportResponse$Type extends MessageType<GetReportResponse> {
    constructor() {
        super("elephant.repository.GetReportResponse", [
            { no: 1, name: "report", kind: "message", T: () => Report },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "next_execution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetReportResponse>): GetReportResponse {
        const message = { enabled: false, nextExecution: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReportResponse): GetReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* string next_execution */ 3:
                    message.nextExecution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        /* string next_execution = 3; */
        if (message.nextExecution !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nextExecution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetReportResponse
 */
export const GetReportResponse = new GetReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateReportRequest$Type extends MessageType<UpdateReportRequest> {
    constructor() {
        super("elephant.repository.UpdateReportRequest", [
            { no: 1, name: "report", kind: "message", T: () => Report },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateReportRequest>): UpdateReportRequest {
        const message = { enabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateReportRequest): UpdateReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateReportRequest
 */
export const UpdateReportRequest = new UpdateReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Report$Type extends MessageType<Report> {
    constructor() {
        super("elephant.repository.Report", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "generate_sheet", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cron_expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "cron_timezone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "slack_channels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "queries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReportQuery }
        ]);
    }
    create(value?: PartialMessage<Report>): Report {
        const message = { name: "", title: "", generateSheet: false, cronExpression: "", cronTimezone: "", slackChannels: [], queries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Report>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Report): Report {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* bool generate_sheet */ 3:
                    message.generateSheet = reader.bool();
                    break;
                case /* string cron_expression */ 4:
                    message.cronExpression = reader.string();
                    break;
                case /* string cron_timezone */ 7:
                    message.cronTimezone = reader.string();
                    break;
                case /* repeated string slack_channels */ 5:
                    message.slackChannels.push(reader.string());
                    break;
                case /* repeated elephant.repository.ReportQuery queries */ 6:
                    message.queries.push(ReportQuery.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Report, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* bool generate_sheet = 3; */
        if (message.generateSheet !== false)
            writer.tag(3, WireType.Varint).bool(message.generateSheet);
        /* string cron_expression = 4; */
        if (message.cronExpression !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cronExpression);
        /* string cron_timezone = 7; */
        if (message.cronTimezone !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cronTimezone);
        /* repeated string slack_channels = 5; */
        for (let i = 0; i < message.slackChannels.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.slackChannels[i]);
        /* repeated elephant.repository.ReportQuery queries = 6; */
        for (let i = 0; i < message.queries.length; i++)
            ReportQuery.internalBinaryWrite(message.queries[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Report
 */
export const Report = new Report$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportQuery$Type extends MessageType<ReportQuery> {
    constructor() {
        super("elephant.repository.ReportQuery", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "summarise", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value_processing", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReportValue }
        ]);
    }
    create(value?: PartialMessage<ReportQuery>): ReportQuery {
        const message = { name: "", summarise: [], sql: "", valueProcessing: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReportQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportQuery): ReportQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated int32 summarise */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.summarise.push(reader.int32());
                    else
                        message.summarise.push(reader.int32());
                    break;
                case /* string sql */ 3:
                    message.sql = reader.string();
                    break;
                case /* repeated elephant.repository.ReportValue value_processing */ 4:
                    message.valueProcessing.push(ReportValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated int32 summarise = 2; */
        if (message.summarise.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.summarise.length; i++)
                writer.int32(message.summarise[i]);
            writer.join();
        }
        /* string sql = 3; */
        if (message.sql !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sql);
        /* repeated elephant.repository.ReportValue value_processing = 4; */
        for (let i = 0; i < message.valueProcessing.length; i++)
            ReportValue.internalBinaryWrite(message.valueProcessing[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ReportQuery
 */
export const ReportQuery = new ReportQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReportValue$Type extends MessageType<ReportValue> {
    constructor() {
        super("elephant.repository.ReportValue", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "processors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReportValue>): ReportValue {
        const message = { column: "", processors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReportValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReportValue): ReportValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* repeated string processors */ 2:
                    message.processors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReportValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* repeated string processors = 2; */
        for (let i = 0; i < message.processors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.processors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ReportValue
 */
export const ReportValue = new ReportValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateReportResponse$Type extends MessageType<UpdateReportResponse> {
    constructor() {
        super("elephant.repository.UpdateReportResponse", [
            { no: 1, name: "next_execution", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateReportResponse>): UpdateReportResponse {
        const message = { nextExecution: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateReportResponse): UpdateReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_execution */ 1:
                    message.nextExecution = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_execution = 1; */
        if (message.nextExecution !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nextExecution);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateReportResponse
 */
export const UpdateReportResponse = new UpdateReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRulesRequest$Type extends MessageType<GetStatusRulesRequest> {
    constructor() {
        super("elephant.repository.GetStatusRulesRequest", []);
    }
    create(value?: PartialMessage<GetStatusRulesRequest>): GetStatusRulesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStatusRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRulesRequest): GetStatusRulesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetStatusRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRulesRequest
 */
export const GetStatusRulesRequest = new GetStatusRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRulesResponse$Type extends MessageType<GetStatusRulesResponse> {
    constructor() {
        super("elephant.repository.GetStatusRulesResponse", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusRule }
        ]);
    }
    create(value?: PartialMessage<GetStatusRulesResponse>): GetStatusRulesResponse {
        const message = { rules: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStatusRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRulesResponse): GetStatusRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.StatusRule rules */ 1:
                    message.rules.push(StatusRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.StatusRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            StatusRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusRulesResponse
 */
export const GetStatusRulesResponse = new GetStatusRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusesRequest$Type extends MessageType<GetStatusesRequest> {
    constructor() {
        super("elephant.repository.GetStatusesRequest", []);
    }
    create(value?: PartialMessage<GetStatusesRequest>): GetStatusesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStatusesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusesRequest): GetStatusesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetStatusesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusesRequest
 */
export const GetStatusesRequest = new GetStatusesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatus$Type extends MessageType<WorkflowStatus> {
    constructor() {
        super("elephant.repository.WorkflowStatus", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatus>): WorkflowStatus {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatus): WorkflowStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.WorkflowStatus
 */
export const WorkflowStatus = new WorkflowStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusesResponse$Type extends MessageType<GetStatusesResponse> {
    constructor() {
        super("elephant.repository.GetStatusesResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorkflowStatus }
        ]);
    }
    create(value?: PartialMessage<GetStatusesResponse>): GetStatusesResponse {
        const message = { statuses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStatusesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusesResponse): GetStatusesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.WorkflowStatus statuses */ 1:
                    message.statuses.push(WorkflowStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.WorkflowStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            WorkflowStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetStatusesResponse
 */
export const GetStatusesResponse = new GetStatusesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusRequest$Type extends MessageType<UpdateStatusRequest> {
    constructor() {
        super("elephant.repository.UpdateStatusRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateStatusRequest>): UpdateStatusRequest {
        const message = { name: "", disabled: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusRequest): UpdateStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool disabled */ 2:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool disabled = 2; */
        if (message.disabled !== false)
            writer.tag(2, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateStatusRequest
 */
export const UpdateStatusRequest = new UpdateStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusResponse$Type extends MessageType<UpdateStatusResponse> {
    constructor() {
        super("elephant.repository.UpdateStatusResponse", []);
    }
    create(value?: PartialMessage<UpdateStatusResponse>): UpdateStatusResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusResponse): UpdateStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateStatusResponse
 */
export const UpdateStatusResponse = new UpdateStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStatusRuleRequest$Type extends MessageType<CreateStatusRuleRequest> {
    constructor() {
        super("elephant.repository.CreateStatusRuleRequest", [
            { no: 1, name: "rule", kind: "message", T: () => StatusRule }
        ]);
    }
    create(value?: PartialMessage<CreateStatusRuleRequest>): CreateStatusRuleRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateStatusRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStatusRuleRequest): CreateStatusRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.StatusRule rule */ 1:
                    message.rule = StatusRule.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStatusRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.StatusRule rule = 1; */
        if (message.rule)
            StatusRule.internalBinaryWrite(message.rule, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateStatusRuleRequest
 */
export const CreateStatusRuleRequest = new CreateStatusRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusRule$Type extends MessageType<StatusRule> {
    constructor() {
        super("elephant.repository.StatusRule", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "access_rule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "applies_to", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "for_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusRule>): StatusRule {
        const message = { name: "", description: "", accessRule: false, appliesTo: [], forTypes: [], expression: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusRule): StatusRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* bool access_rule */ 3:
                    message.accessRule = reader.bool();
                    break;
                case /* repeated string applies_to */ 4:
                    message.appliesTo.push(reader.string());
                    break;
                case /* repeated string for_types */ 5:
                    message.forTypes.push(reader.string());
                    break;
                case /* string expression */ 6:
                    message.expression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* bool access_rule = 3; */
        if (message.accessRule !== false)
            writer.tag(3, WireType.Varint).bool(message.accessRule);
        /* repeated string applies_to = 4; */
        for (let i = 0; i < message.appliesTo.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.appliesTo[i]);
        /* repeated string for_types = 5; */
        for (let i = 0; i < message.forTypes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.forTypes[i]);
        /* string expression = 6; */
        if (message.expression !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.expression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusRule
 */
export const StatusRule = new StatusRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStatusRuleResponse$Type extends MessageType<CreateStatusRuleResponse> {
    constructor() {
        super("elephant.repository.CreateStatusRuleResponse", []);
    }
    create(value?: PartialMessage<CreateStatusRuleResponse>): CreateStatusRuleResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateStatusRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStatusRuleResponse): CreateStatusRuleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateStatusRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.CreateStatusRuleResponse
 */
export const CreateStatusRuleResponse = new CreateStatusRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRuleRequest$Type extends MessageType<DeleteStatusRuleRequest> {
    constructor() {
        super("elephant.repository.DeleteStatusRuleRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteStatusRuleRequest>): DeleteStatusRuleRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRuleRequest): DeleteStatusRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteStatusRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteStatusRuleRequest
 */
export const DeleteStatusRuleRequest = new DeleteStatusRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRuleResponse$Type extends MessageType<DeleteStatusRuleResponse> {
    constructor() {
        super("elephant.repository.DeleteStatusRuleResponse", []);
    }
    create(value?: PartialMessage<DeleteStatusRuleResponse>): DeleteStatusRuleResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRuleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRuleResponse): DeleteStatusRuleResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteStatusRuleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteStatusRuleResponse
 */
export const DeleteStatusRuleResponse = new DeleteStatusRuleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentRequest$Type extends MessageType<GetDocumentRequest> {
    constructor() {
        super("elephant.repository.GetDocumentRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "lock", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocumentRequest>): GetDocumentRequest {
        const message = { uuid: "", version: 0n, status: "", lock: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentRequest): GetDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string status */ 3:
                    message.status = reader.string();
                    break;
                case /* bool lock */ 4:
                    message.lock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string status = 3; */
        if (message.status !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status);
        /* bool lock = 4; */
        if (message.lock !== false)
            writer.tag(4, WireType.Varint).bool(message.lock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentRequest
 */
export const GetDocumentRequest = new GetDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocumentResponse$Type extends MessageType<GetDocumentResponse> {
    constructor() {
        super("elephant.repository.GetDocumentResponse", [
            { no: 1, name: "document", kind: "message", T: () => Document },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocumentResponse>): GetDocumentResponse {
        const message = { version: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocumentResponse): GetDocumentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetDocumentResponse
 */
export const GetDocumentResponse = new GetDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryRequest$Type extends MessageType<GetHistoryRequest> {
    constructor() {
        super("elephant.repository.GetHistoryRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "before", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetHistoryRequest>): GetHistoryRequest {
        const message = { uuid: "", before: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryRequest): GetHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* int64 before */ 2:
                    message.before = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* int64 before = 2; */
        if (message.before !== 0n)
            writer.tag(2, WireType.Varint).int64(message.before);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetHistoryRequest
 */
export const GetHistoryRequest = new GetHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryResponse$Type extends MessageType<GetHistoryResponse> {
    constructor() {
        super("elephant.repository.GetHistoryResponse", [
            { no: 1, name: "versions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DocumentVersion }
        ]);
    }
    create(value?: PartialMessage<GetHistoryResponse>): GetHistoryResponse {
        const message = { versions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryResponse): GetHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.DocumentVersion versions */ 1:
                    message.versions.push(DocumentVersion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.DocumentVersion versions = 1; */
        for (let i = 0; i < message.versions.length; i++)
            DocumentVersion.internalBinaryWrite(message.versions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetHistoryResponse
 */
export const GetHistoryResponse = new GetHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentVersion$Type extends MessageType<DocumentVersion> {
    constructor() {
        super("elephant.repository.DocumentVersion", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<DocumentVersion>): DocumentVersion {
        const message = { version: 0n, created: "", creator: "", meta: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentVersion): DocumentVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string created */ 2:
                    message.created = reader.string();
                    break;
                case /* string creator */ 3:
                    message.creator = reader.string();
                    break;
                case /* map<string, string> meta */ 4:
                    this.binaryReadMap4(message.meta, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DocumentVersion["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentVersion["meta"] | undefined, val: DocumentVersion["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentVersion.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DocumentVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        /* string created = 2; */
        if (message.created !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.created);
        /* string creator = 3; */
        if (message.creator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.creator);
        /* map<string, string> meta = 4; */
        for (let k of Object.keys(message.meta))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentVersion
 */
export const DocumentVersion = new DocumentVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRequest$Type extends MessageType<UpdateRequest> {
    constructor() {
        super("elephant.repository.UpdateRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "document", kind: "message", T: () => Document },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "status", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatusUpdate },
            { no: 6, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry },
            { no: 7, name: "import_directive", kind: "message", T: () => ImportDirective }
        ]);
    }
    create(value?: PartialMessage<UpdateRequest>): UpdateRequest {
        const message = { uuid: "", meta: {}, ifMatch: 0n, status: [], acl: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRequest): UpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* elephant.repository.Document document */ 2:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 4:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                case /* repeated elephant.repository.StatusUpdate status */ 5:
                    message.status.push(StatusUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 6:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* elephant.repository.ImportDirective import_directive */ 7:
                    message.importDirective = ImportDirective.internalBinaryRead(reader, reader.uint32(), options, message.importDirective);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: UpdateRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateRequest["meta"] | undefined, val: UpdateRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.UpdateRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: UpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* elephant.repository.Document document = 2; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> meta = 3; */
        for (let k of Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 4; */
        if (message.ifMatch !== 0n)
            writer.tag(4, WireType.Varint).int64(message.ifMatch);
        /* repeated elephant.repository.StatusUpdate status = 5; */
        for (let i = 0; i < message.status.length; i++)
            StatusUpdate.internalBinaryWrite(message.status[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.ACLEntry acl = 6; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* elephant.repository.ImportDirective import_directive = 7; */
        if (message.importDirective)
            ImportDirective.internalBinaryWrite(message.importDirective, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateRequest
 */
export const UpdateRequest = new UpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportDirective$Type extends MessageType<ImportDirective> {
    constructor() {
        super("elephant.repository.ImportDirective", [
            { no: 1, name: "originallyCreated", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "originalCreator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImportDirective>): ImportDirective {
        const message = { originallyCreated: "", originalCreator: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImportDirective>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportDirective): ImportDirective {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string originallyCreated */ 1:
                    message.originallyCreated = reader.string();
                    break;
                case /* string originalCreator */ 2:
                    message.originalCreator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportDirective, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string originallyCreated = 1; */
        if (message.originallyCreated !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.originallyCreated);
        /* string originalCreator = 2; */
        if (message.originalCreator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.originalCreator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ImportDirective
 */
export const ImportDirective = new ImportDirective$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("elephant.repository.UpdateResponse", [
            { no: 1, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = { version: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 version */ 1:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 version = 1; */
        if (message.version !== 0n)
            writer.tag(1, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateRequest$Type extends MessageType<ValidateRequest> {
    constructor() {
        super("elephant.repository.ValidateRequest", [
            { no: 1, name: "document", kind: "message", T: () => Document }
        ]);
    }
    create(value?: PartialMessage<ValidateRequest>): ValidateRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateRequest): ValidateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Document document */ 1:
                    message.document = Document.internalBinaryRead(reader, reader.uint32(), options, message.document);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Document document = 1; */
        if (message.document)
            Document.internalBinaryWrite(message.document, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidateRequest
 */
export const ValidateRequest = new ValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateResponse$Type extends MessageType<ValidateResponse> {
    constructor() {
        super("elephant.repository.ValidateResponse", [
            { no: 1, name: "errors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidationResult }
        ]);
    }
    create(value?: PartialMessage<ValidateResponse>): ValidateResponse {
        const message = { errors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateResponse): ValidateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.ValidationResult errors */ 1:
                    message.errors.push(ValidationResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.ValidationResult errors = 1; */
        for (let i = 0; i < message.errors.length; i++)
            ValidationResult.internalBinaryWrite(message.errors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidateResponse
 */
export const ValidateResponse = new ValidateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidationResult$Type extends MessageType<ValidationResult> {
    constructor() {
        super("elephant.repository.ValidationResult", [
            { no: 1, name: "entity", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EntityRef },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidationResult>): ValidationResult {
        const message = { entity: [], error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidationResult): ValidationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.EntityRef entity */ 1:
                    message.entity.push(EntityRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.EntityRef entity = 1; */
        for (let i = 0; i < message.entity.length; i++)
            EntityRef.internalBinaryWrite(message.entity[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ValidationResult
 */
export const ValidationResult = new ValidationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityRef$Type extends MessageType<EntityRef> {
    constructor() {
        super("elephant.repository.EntityRef", [
            { no: 1, name: "ref_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "rel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EntityRef>): EntityRef {
        const message = { refType: "", kind: "", index: 0n, name: "", type: "", rel: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityRef): EntityRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ref_type */ 1:
                    message.refType = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* int64 index */ 3:
                    message.index = reader.int64().toBigInt();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string rel */ 6:
                    message.rel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ref_type = 1; */
        if (message.refType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refType);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* int64 index = 3; */
        if (message.index !== 0n)
            writer.tag(3, WireType.Varint).int64(message.index);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string rel = 6; */
        if (message.rel !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.rel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.EntityRef
 */
export const EntityRef = new EntityRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusUpdate$Type extends MessageType<StatusUpdate> {
    constructor() {
        super("elephant.repository.StatusUpdate", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StatusUpdate>): StatusUpdate {
        const message = { name: "", version: 0n, meta: {}, ifMatch: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusUpdate): StatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* map<string, string> meta */ 3:
                    this.binaryReadMap3(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 4:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: StatusUpdate["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatusUpdate["meta"] | undefined, val: StatusUpdate["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.StatusUpdate.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: StatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* map<string, string> meta = 3; */
        for (let k of Object.keys(message.meta))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 4; */
        if (message.ifMatch !== 0n)
            writer.tag(4, WireType.Varint).int64(message.ifMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.StatusUpdate
 */
export const StatusUpdate = new StatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePermissionsRequest$Type extends MessageType<UpdatePermissionsRequest> {
    constructor() {
        super("elephant.repository.UpdatePermissionsRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry }
        ]);
    }
    create(value?: PartialMessage<UpdatePermissionsRequest>): UpdatePermissionsRequest {
        const message = { uuid: "", list: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePermissionsRequest): UpdatePermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated elephant.repository.ACLEntry list */ 2:
                    message.list.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* repeated elephant.repository.ACLEntry list = 2; */
        for (let i = 0; i < message.list.length; i++)
            ACLEntry.internalBinaryWrite(message.list[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdatePermissionsRequest
 */
export const UpdatePermissionsRequest = new UpdatePermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePermissionsResponse$Type extends MessageType<UpdatePermissionsResponse> {
    constructor() {
        super("elephant.repository.UpdatePermissionsResponse", []);
    }
    create(value?: PartialMessage<UpdatePermissionsResponse>): UpdatePermissionsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePermissionsResponse): UpdatePermissionsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdatePermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.UpdatePermissionsResponse
 */
export const UpdatePermissionsResponse = new UpdatePermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentRequest$Type extends MessageType<DeleteDocumentRequest> {
    constructor() {
        super("elephant.repository.DeleteDocumentRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "if_match", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDocumentRequest>): DeleteDocumentRequest {
        const message = { uuid: "", meta: {}, ifMatch: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentRequest): DeleteDocumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* map<string, string> meta */ 2:
                    this.binaryReadMap2(message.meta, reader, options);
                    break;
                case /* int64 if_match */ 3:
                    message.ifMatch = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: DeleteDocumentRequest["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteDocumentRequest["meta"] | undefined, val: DeleteDocumentRequest["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DeleteDocumentRequest.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteDocumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* map<string, string> meta = 2; */
        for (let k of Object.keys(message.meta))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        /* int64 if_match = 3; */
        if (message.ifMatch !== 0n)
            writer.tag(3, WireType.Varint).int64(message.ifMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteDocumentRequest
 */
export const DeleteDocumentRequest = new DeleteDocumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocumentResponse$Type extends MessageType<DeleteDocumentResponse> {
    constructor() {
        super("elephant.repository.DeleteDocumentResponse", []);
    }
    create(value?: PartialMessage<DeleteDocumentResponse>): DeleteDocumentResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteDocumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocumentResponse): DeleteDocumentResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteDocumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteDocumentResponse
 */
export const DeleteDocumentResponse = new DeleteDocumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaRequest$Type extends MessageType<GetMetaRequest> {
    constructor() {
        super("elephant.repository.GetMetaRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMetaRequest>): GetMetaRequest {
        const message = { uuid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMetaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaRequest): GetMetaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaRequest
 */
export const GetMetaRequest = new GetMetaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetaResponse$Type extends MessageType<GetMetaResponse> {
    constructor() {
        super("elephant.repository.GetMetaResponse", [
            { no: 1, name: "meta", kind: "message", T: () => DocumentMeta }
        ]);
    }
    create(value?: PartialMessage<GetMetaResponse>): GetMetaResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMetaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetaResponse): GetMetaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.DocumentMeta meta */ 1:
                    message.meta = DocumentMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.DocumentMeta meta = 1; */
        if (message.meta)
            DocumentMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetaResponse
 */
export const GetMetaResponse = new GetMetaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentMeta$Type extends MessageType<DocumentMeta> {
    constructor() {
        super("elephant.repository.DocumentMeta", [
            { no: 1, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "modified", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "currentVersion", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "heads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Status } },
            { no: 5, name: "acl", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ACLEntry }
        ]);
    }
    create(value?: PartialMessage<DocumentMeta>): DocumentMeta {
        const message = { created: "", modified: "", currentVersion: 0n, heads: {}, acl: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DocumentMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentMeta): DocumentMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string created */ 1:
                    message.created = reader.string();
                    break;
                case /* string modified */ 2:
                    message.modified = reader.string();
                    break;
                case /* int64 currentVersion */ 3:
                    message.currentVersion = reader.int64().toBigInt();
                    break;
                case /* map<string, elephant.repository.Status> heads */ 4:
                    this.binaryReadMap4(message.heads, reader, options);
                    break;
                case /* repeated elephant.repository.ACLEntry acl */ 5:
                    message.acl.push(ACLEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: DocumentMeta["heads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DocumentMeta["heads"] | undefined, val: DocumentMeta["heads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Status.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.DocumentMeta.heads");
            }
        }
        map[key ?? ""] = val ?? Status.create();
    }
    internalBinaryWrite(message: DocumentMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string created = 1; */
        if (message.created !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.created);
        /* string modified = 2; */
        if (message.modified !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modified);
        /* int64 currentVersion = 3; */
        if (message.currentVersion !== 0n)
            writer.tag(3, WireType.Varint).int64(message.currentVersion);
        /* map<string, elephant.repository.Status> heads = 4; */
        for (let k of Object.keys(message.heads)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Status.internalBinaryWrite(message.heads[k], writer, options);
            writer.join().join();
        }
        /* repeated elephant.repository.ACLEntry acl = 5; */
        for (let i = 0; i < message.acl.length; i++)
            ACLEntry.internalBinaryWrite(message.acl[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DocumentMeta
 */
export const DocumentMeta = new DocumentMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("elephant.repository.Status", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "created", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = { id: 0n, version: 0n, creator: "", created: "", meta: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* string creator */ 3:
                    message.creator = reader.string();
                    break;
                case /* string created */ 4:
                    message.created = reader.string();
                    break;
                case /* map<string, string> meta */ 5:
                    this.binaryReadMap5(message.meta, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Status["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Status["meta"] | undefined, val: Status["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.Status.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* string creator = 3; */
        if (message.creator !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.creator);
        /* string created = 4; */
        if (message.created !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.created);
        /* map<string, string> meta = 5; */
        for (let k of Object.keys(message.meta))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ACLEntry$Type extends MessageType<ACLEntry> {
    constructor() {
        super("elephant.repository.ACLEntry", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "permissions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ACLEntry>): ACLEntry {
        const message = { uri: "", permissions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ACLEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ACLEntry): ACLEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* repeated string permissions */ 2:
                    message.permissions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ACLEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* repeated string permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.permissions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.ACLEntry
 */
export const ACLEntry = new ACLEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Document$Type extends MessageType<Document> {
    constructor() {
        super("elephant.repository.Document", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "content", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 7, name: "meta", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 8, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 9, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Document>): Document {
        const message = { uuid: "", type: "", uri: "", url: "", title: "", content: [], meta: [], links: [], language: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Document>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Document): Document {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string uri */ 3:
                    message.uri = reader.string();
                    break;
                case /* string url */ 4:
                    message.url = reader.string();
                    break;
                case /* string title */ 5:
                    message.title = reader.string();
                    break;
                case /* repeated elephant.repository.Block content */ 6:
                    message.content.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.Block meta */ 7:
                    message.meta.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.Block links */ 8:
                    message.links.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string language */ 9:
                    message.language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Document, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string uri = 3; */
        if (message.uri !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uri);
        /* string url = 4; */
        if (message.url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.url);
        /* string title = 5; */
        if (message.title !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* repeated elephant.repository.Block content = 6; */
        for (let i = 0; i < message.content.length; i++)
            Block.internalBinaryWrite(message.content[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.Block meta = 7; */
        for (let i = 0; i < message.meta.length; i++)
            Block.internalBinaryWrite(message.meta[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.Block links = 8; */
        for (let i = 0; i < message.links.length; i++)
            Block.internalBinaryWrite(message.links[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string language = 9; */
        if (message.language !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Document
 */
export const Document = new Document$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Block$Type extends MessageType<Block> {
    constructor() {
        super("elephant.repository.Block", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 8, name: "rel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "contentType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 14, name: "content", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 15, name: "meta", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block }
        ]);
    }
    create(value?: PartialMessage<Block>): Block {
        const message = { id: "", uuid: "", uri: "", url: "", type: "", title: "", data: {}, rel: "", role: "", name: "", value: "", contentType: "", links: [], content: [], meta: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Block>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Block): Block {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* string uri */ 3:
                    message.uri = reader.string();
                    break;
                case /* string url */ 4:
                    message.url = reader.string();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string title */ 6:
                    message.title = reader.string();
                    break;
                case /* map<string, string> data */ 7:
                    this.binaryReadMap7(message.data, reader, options);
                    break;
                case /* string rel */ 8:
                    message.rel = reader.string();
                    break;
                case /* string role */ 9:
                    message.role = reader.string();
                    break;
                case /* string name */ 10:
                    message.name = reader.string();
                    break;
                case /* string value */ 11:
                    message.value = reader.string();
                    break;
                case /* string contentType */ 12:
                    message.contentType = reader.string();
                    break;
                case /* repeated elephant.repository.Block links */ 13:
                    message.links.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.Block content */ 14:
                    message.content.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated elephant.repository.Block meta */ 15:
                    message.meta.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: Block["data"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Block["data"] | undefined, val: Block["data"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.Block.data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Block, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* string uri = 3; */
        if (message.uri !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uri);
        /* string url = 4; */
        if (message.url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.url);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string title = 6; */
        if (message.title !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.title);
        /* map<string, string> data = 7; */
        for (let k of Object.keys(message.data))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.data[k]).join();
        /* string rel = 8; */
        if (message.rel !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.rel);
        /* string role = 9; */
        if (message.role !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.role);
        /* string name = 10; */
        if (message.name !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.name);
        /* string value = 11; */
        if (message.value !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.value);
        /* string contentType = 12; */
        if (message.contentType !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.contentType);
        /* repeated elephant.repository.Block links = 13; */
        for (let i = 0; i < message.links.length; i++)



            Block.internalBinaryWrite(message.links[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.Block content = 14; */
        for (let i = 0; i < message.content.length; i++)
            Block.internalBinaryWrite(message.content[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated elephant.repository.Block meta = 15; */
        for (let i = 0; i < message.meta.length; i++)
            Block.internalBinaryWrite(message.meta[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Block
 */
export const Block = new Block$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterSchemaRequest$Type extends MessageType<RegisterSchemaRequest> {
    constructor() {
        super("elephant.repository.RegisterSchemaRequest", [
            { no: 1, name: "schema", kind: "message", T: () => Schema },
            { no: 2, name: "activate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterSchemaRequest>): RegisterSchemaRequest {
        const message = { activate: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterSchemaRequest): RegisterSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* elephant.repository.Schema schema */ 1:
                    message.schema = Schema.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                case /* bool activate */ 2:
                    message.activate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* elephant.repository.Schema schema = 1; */
        if (message.schema)
            Schema.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool activate = 2; */
        if (message.activate !== false)
            writer.tag(2, WireType.Varint).bool(message.activate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterSchemaRequest
 */
export const RegisterSchemaRequest = new RegisterSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterSchemaResponse$Type extends MessageType<RegisterSchemaResponse> {
    constructor() {
        super("elephant.repository.RegisterSchemaResponse", []);
    }
    create(value?: PartialMessage<RegisterSchemaResponse>): RegisterSchemaResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterSchemaResponse): RegisterSchemaResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterSchemaResponse
 */
export const RegisterSchemaResponse = new RegisterSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActiveSchemaRequest$Type extends MessageType<SetActiveSchemaRequest> {
    constructor() {
        super("elephant.repository.SetActiveSchemaRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deactivate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetActiveSchemaRequest>): SetActiveSchemaRequest {
        const message = { name: "", version: "", deactivate: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetActiveSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetActiveSchemaRequest): SetActiveSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* bool deactivate */ 3:
                    message.deactivate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetActiveSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* bool deactivate = 3; */
        if (message.deactivate !== false)
            writer.tag(3, WireType.Varint).bool(message.deactivate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetActiveSchemaRequest
 */
export const SetActiveSchemaRequest = new SetActiveSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActiveSchemaResponse$Type extends MessageType<SetActiveSchemaResponse> {
    constructor() {
        super("elephant.repository.SetActiveSchemaResponse", []);
    }
    create(value?: PartialMessage<SetActiveSchemaResponse>): SetActiveSchemaResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetActiveSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetActiveSchemaResponse): SetActiveSchemaResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetActiveSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.SetActiveSchemaResponse
 */
export const SetActiveSchemaResponse = new SetActiveSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("elephant.repository.GetSchemaRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = { name: "", version: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("elephant.repository.GetSchemaResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spec", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = { version: "", spec: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* bytes spec */ 2:
                    message.spec = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* bytes spec = 2; */
        if (message.spec.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllActiveSchemasRequest$Type extends MessageType<GetAllActiveSchemasRequest> {
    constructor() {
        super("elephant.repository.GetAllActiveSchemasRequest", [
            { no: 1, name: "wait_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "known", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetAllActiveSchemasRequest>): GetAllActiveSchemasRequest {
        const message = { waitSeconds: 0n, known: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllActiveSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllActiveSchemasRequest): GetAllActiveSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 wait_seconds */ 1:
                    message.waitSeconds = reader.int64().toBigInt();
                    break;
                case /* map<string, string> known */ 2:
                    this.binaryReadMap2(message.known, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GetAllActiveSchemasRequest["known"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetAllActiveSchemasRequest["known"] | undefined, val: GetAllActiveSchemasRequest["known"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field elephant.repository.GetAllActiveSchemasRequest.known");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetAllActiveSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 wait_seconds = 1; */
        if (message.waitSeconds !== 0n)
            writer.tag(1, WireType.Varint).int64(message.waitSeconds);
        /* map<string, string> known = 2; */
        for (let k of Object.keys(message.known))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.known[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAllActiveSchemasRequest
 */
export const GetAllActiveSchemasRequest = new GetAllActiveSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllActiveSchemasResponse$Type extends MessageType<GetAllActiveSchemasResponse> {
    constructor() {
        super("elephant.repository.GetAllActiveSchemasResponse", [
            { no: 1, name: "schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Schema }
        ]);
    }
    create(value?: PartialMessage<GetAllActiveSchemasResponse>): GetAllActiveSchemasResponse {
        const message = { schemas: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllActiveSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllActiveSchemasResponse): GetAllActiveSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.Schema schemas */ 1:
                    message.schemas.push(Schema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllActiveSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.Schema schemas = 1; */
        for (let i = 0; i < message.schemas.length; i++)
            Schema.internalBinaryWrite(message.schemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetAllActiveSchemasResponse
 */
export const GetAllActiveSchemasResponse = new GetAllActiveSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("elephant.repository.Schema", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "spec", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = { name: "", version: "", spec: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* string spec */ 3:
                    message.spec = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* string spec = 3; */
        if (message.spec !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.spec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricKindRequest$Type extends MessageType<RegisterMetricKindRequest> {
    constructor() {
        super("elephant.repository.RegisterMetricKindRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregation", kind: "enum", T: () => ["elephant.repository.MetricAggregation", MetricAggregation] }
        ]);
    }
    create(value?: PartialMessage<RegisterMetricKindRequest>): RegisterMetricKindRequest {
        const message = { name: "", aggregation: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricKindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricKindRequest): RegisterMetricKindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* elephant.repository.MetricAggregation aggregation */ 2:
                    message.aggregation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetricKindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* elephant.repository.MetricAggregation aggregation = 2; */
        if (message.aggregation !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricKindRequest
 */
export const RegisterMetricKindRequest = new RegisterMetricKindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricKindResponse$Type extends MessageType<RegisterMetricKindResponse> {
    constructor() {
        super("elephant.repository.RegisterMetricKindResponse", []);
    }
    create(value?: PartialMessage<RegisterMetricKindResponse>): RegisterMetricKindResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricKindResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricKindResponse): RegisterMetricKindResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetricKindResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricKindResponse
 */
export const RegisterMetricKindResponse = new RegisterMetricKindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetricKindRequest$Type extends MessageType<DeleteMetricKindRequest> {
    constructor() {
        super("elephant.repository.DeleteMetricKindRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMetricKindRequest>): DeleteMetricKindRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteMetricKindRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetricKindRequest): DeleteMetricKindRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMetricKindRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteMetricKindRequest
 */
export const DeleteMetricKindRequest = new DeleteMetricKindRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetricKindResponse$Type extends MessageType<DeleteMetricKindResponse> {
    constructor() {
        super("elephant.repository.DeleteMetricKindResponse", []);
    }
    create(value?: PartialMessage<DeleteMetricKindResponse>): DeleteMetricKindResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteMetricKindResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetricKindResponse): DeleteMetricKindResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteMetricKindResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.DeleteMetricKindResponse
 */
export const DeleteMetricKindResponse = new DeleteMetricKindResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricKindsRequest$Type extends MessageType<GetMetricKindsRequest> {
    constructor() {
        super("elephant.repository.GetMetricKindsRequest", []);
    }
    create(value?: PartialMessage<GetMetricKindsRequest>): GetMetricKindsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMetricKindsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricKindsRequest): GetMetricKindsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMetricKindsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricKindsRequest
 */
export const GetMetricKindsRequest = new GetMetricKindsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricKindsResponse$Type extends MessageType<GetMetricKindsResponse> {
    constructor() {
        super("elephant.repository.GetMetricKindsResponse", [
            { no: 1, name: "kinds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetricKind }
        ]);
    }
    create(value?: PartialMessage<GetMetricKindsResponse>): GetMetricKindsResponse {
        const message = { kinds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMetricKindsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricKindsResponse): GetMetricKindsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated elephant.repository.MetricKind kinds */ 1:
                    message.kinds.push(MetricKind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMetricKindsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated elephant.repository.MetricKind kinds = 1; */
        for (let i = 0; i < message.kinds.length; i++)
            MetricKind.internalBinaryWrite(message.kinds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.GetMetricKindsResponse
 */
export const GetMetricKindsResponse = new GetMetricKindsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricKind$Type extends MessageType<MetricKind> {
    constructor() {
        super("elephant.repository.MetricKind", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregation", kind: "enum", T: () => ["elephant.repository.MetricAggregation", MetricAggregation] }
        ]);
    }
    create(value?: PartialMessage<MetricKind>): MetricKind {
        const message = { name: "", aggregation: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MetricKind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricKind): MetricKind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* elephant.repository.MetricAggregation aggregation */ 2:
                    message.aggregation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetricKind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* elephant.repository.MetricAggregation aggregation = 2; */
        if (message.aggregation !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.MetricKind
 */
export const MetricKind = new MetricKind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricRequest$Type extends MessageType<RegisterMetricRequest> {
    constructor() {
        super("elephant.repository.RegisterMetricRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterMetricRequest>): RegisterMetricRequest {
        const message = { uuid: "", kind: "", label: "", value: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricRequest): RegisterMetricRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string label */ 3:
                    message.label = reader.string();
                    break;
                case /* int64 value */ 5:
                    message.value = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterMetricRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string label = 3; */
        if (message.label !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        /* int64 value = 5; */
        if (message.value !== 0n)
            writer.tag(5, WireType.Varint).int64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricRequest
 */
export const RegisterMetricRequest = new RegisterMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterMetricResponse$Type extends MessageType<RegisterMetricResponse> {
    constructor() {
        super("elephant.repository.RegisterMetricResponse", []);
    }
    create(value?: PartialMessage<RegisterMetricResponse>): RegisterMetricResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterMetricResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterMetricResponse): RegisterMetricResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RegisterMetricResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message elephant.repository.RegisterMetricResponse
 */
export const RegisterMetricResponse = new RegisterMetricResponse$Type();
/**
 * @generated ServiceType for protobuf service elephant.repository.Documents
 */
export const Documents = new ServiceType("elephant.repository.Documents", [
    { name: "Get", options: {}, I: GetDocumentRequest, O: GetDocumentResponse },
    { name: "GetHistory", options: {}, I: GetHistoryRequest, O: GetHistoryResponse },
    { name: "Update", options: {}, I: UpdateRequest, O: UpdateResponse },
    { name: "Validate", options: {}, I: ValidateRequest, O: ValidateResponse },
    { name: "Delete", options: {}, I: DeleteDocumentRequest, O: DeleteDocumentResponse },
    { name: "GetMeta", options: {}, I: GetMetaRequest, O: GetMetaResponse },
    { name: "Eventlog", options: {}, I: GetEventlogRequest, O: GetEventlogResponse },
    { name: "GetStatusHistory", options: {}, I: GetStatusHistoryRequest, O: GetStatusHistoryReponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Schemas
 */
export const Schemas = new ServiceType("elephant.repository.Schemas", [
    { name: "Register", options: {}, I: RegisterSchemaRequest, O: RegisterSchemaResponse },
    { name: "SetActive", options: {}, I: SetActiveSchemaRequest, O: SetActiveSchemaResponse },
    { name: "Get", options: {}, I: GetSchemaRequest, O: GetSchemaResponse },
    { name: "GetAllActive", options: {}, I: GetAllActiveSchemasRequest, O: GetAllActiveSchemasResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Workflows
 */
export const Workflows = new ServiceType("elephant.repository.Workflows", [
    { name: "UpdateStatus", options: {}, I: UpdateStatusRequest, O: UpdateStatusResponse },
    { name: "GetStatuses", options: {}, I: GetStatusesRequest, O: GetStatusesResponse },
    { name: "CreateStatusRule", options: {}, I: CreateStatusRuleRequest, O: CreateStatusRuleResponse },
    { name: "DeleteStatusRule", options: {}, I: DeleteStatusRuleRequest, O: DeleteStatusRuleResponse },
    { name: "GetStatusRules", options: {}, I: GetStatusRulesRequest, O: GetStatusRulesResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Reports
 */
export const Reports = new ServiceType("elephant.repository.Reports", [
    { name: "Update", options: {}, I: UpdateReportRequest, O: UpdateReportResponse },
    { name: "Get", options: {}, I: GetReportRequest, O: GetReportResponse },
    { name: "Run", options: {}, I: RunReportRequest, O: RunReportResponse },
    { name: "Test", options: {}, I: TestReportRequest, O: TestReportResponse }
]);
/**
 * @generated ServiceType for protobuf service elephant.repository.Metrics
 */
export const Metrics = new ServiceType("elephant.repository.Metrics", [
    { name: "RegisterKind", options: {}, I: RegisterMetricKindRequest, O: RegisterMetricKindResponse },
    { name: "DeleteKind", options: {}, I: DeleteMetricKindRequest, O: DeleteMetricKindResponse },
    { name: "GetKinds", options: {}, I: GetMetricKindsRequest, O: GetMetricKindsResponse },
    { name: "RegisterMetric", options: {}, I: RegisterMetricRequest, O: RegisterMetricResponse }
]);
